= error_messages_for 'vouchertype', :header_message => default_validation_error_message
/[form:vouchertype]

- existing_bundle = @vouchertype.bundle? && !@vouchertype.new_record?

%p
  %label{:for => :vouchertype_category} Type
  = select 'vouchertype', 'category', options_for_select( |
      [["Bundle", :bundle], |
      ["Comp (single ticket)", :comp], |
      ["Single subscriber voucher", :subscriber], |
      ["Regular revenue voucher", :revenue], |
      ["Nonticket product", :nonticket]], |
      {:selected => @vouchertype.category.to_sym}) |
  = popup_help_for :vouchertype_type
  = observe_field 'vouchertype_category', :function => 'reset_vouchertype_fields(value)'

%p
  %label{:for=>:vouchertype_name} Name
  = text_field 'vouchertype', 'name'

%p#p_vouchertype_price.vtform
  %label{:for=>:vouchertype_price} Price
  = text_field 'vouchertype', 'price', :size => 6

%p#p_vouchertype_account_code.vtform
  %label{:for=>:vouchertype_account_code} Account Code
  = collection_select 'vouchertype', 'account_code_id', AccountCode.find(:all), :id, :name_with_code
  = popup_help_for :vouchertype_account_code

%p#p_vouchertype_offer_public.vtform
  %label{:for=>:vouchertype_offer_public} Availability
  = select "vouchertype", "offer_public", Vouchertype.offer_to
  = popup_help_for :vouchertype_availability

%p#p_vouchertype_season.vtform
  %label{:for=>:vouchertype_season} Season
  - if existing_bundle
    = select "vouchertype", "season", options_for_seasons_range(-5,2,@vouchertype.season || Time.this_season), {}, {:onchange => "$$('input.bundle_component').map(Element.clear); $('included_vouchers').hide(); "}
  - else
    = select "vouchertype", "season", options_for_seasons_range(-5,2,@vouchertype.season || Time.this_season)
  = popup_help_for :vouchertype_season
  - if existing_bundle
    %p.feedback If you change the season of a bundle, first save the change, then edit the bundle again to add vouchers for the new season.


%p#p_vouchertype_fulfillment_needed.clear.vtform
  %label{:for=>:vouchertype_fulfillment_needed} Mail fulfillment needed
  = check_box 'vouchertype', 'fulfillment_needed'
  = popup_help_for :vouchertype_fulfillment_needed

%p#p_vouchertype_walkup_sale_allowed.vtform
  %label{:for=>:vouchertype_walkup_sale_allowed} Walkup sales allowed
  = check_box 'vouchertype', 'walkup_sale_allowed', :disabled => (@vouchertype.bundle? || @vouchertype.subscriber_voucher?)
  = popup_help_for :vouchertype_walkup_sale_allowed

%p#p_vouchertype_changeable.vtform
  %label{:for=>:vouchertype_changeable} Customer can self-change/self-cancel
  = check_box 'vouchertype', 'changeable', :disabled => @vouchertype.bundle?
  = popup_help_for :vouchertype_changeable

%p#p_vouchertype_subscription.vtform
  %label{:for=>:vouchertype_subscription} Qualifies buyer as a Subscriber
  = check_box 'vouchertype', 'subscription'

%p#p_vouchertype_comments.vtform
  %label{:for=>:vouchertype_comments} Comments/description
  = text_area 'vouchertype', 'comments', 'cols' => 40, 'rows' => 3

- if existing_bundle
  /This part of form is for bundle vouchers

  #for_bundles
    %p#p_vouchertype_bundle_sales_start
      %label{:for=>:vouchertype_bundle_sales_start} Sales start
      = datetime_select 'vouchertype', 'bundle_sales_start'

    %p#p_vouchertype_bundle_sales_end
      %label{:for=>:vouchertype_bundle_sales_end} Sales end
      = datetime_select 'vouchertype', 'bundle_sales_end'

    %p#p_vouchertype_bundle_promo_code
      %label{:for => :vouchertype_bundle_promo_code} Promo code(s)
      = text_field 'vouchertype', 'bundle_promo_code', :size => 40
      = popup_help_for 'vouchertype_bundle_promo_code'

    %p#p_vouchertype_vouchertype_included_vouchers
      %label{:for=>:vouchertype_included_vouchers} Included vouchers:
      %br/

    #included_vouchers= render :partial => 'included_vouchers', :locals => {:season => @vouchertype.season }

- else

  %p.strong Note: You  must first define a voucher to be a  bundle, then go back and edit to add the appropriate tickets to the bundle.

/[eoform:vouchertype]


